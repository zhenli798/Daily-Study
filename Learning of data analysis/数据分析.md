# 数据分析实战学习笔记

## 1. 数据分析组成部分

1. **数据采集**
2. **数据挖掘**
3. **数据可视化**

## 2. 数据挖掘

### 2.1 数据挖掘的步骤

1. **商业理解**：从商业的角度理解项目需求，然后再对数据挖掘的目标进行定义。
2. **数据理解**：尝试收集部分数据，然后对数据进行探索，包括数据描述、数据质量验证等。
3. **数据准备**：开始收集数据，并对数据进行清洗、数据集成等操作。
4. **模型建立**：选择和应用各种数据挖掘模型，并进行优化，以便得到更好的分类结果。
5. **模型评估**：对模型进行评价，并检查构建模型的每个步骤，确认模型是否实现了预定的商业目标。
6. **上线发布**

### 2.2 数据挖掘的十大算法

* 由国际权威的学术组织ICDM评选得到。
* **按照不同的目的分为四类**：
  * 分类算法：C4.5，朴素贝叶斯，SVM，KNN，Adaboost，CART
  * 聚类算法：K-Means，EM
  * 关联分析：Apriori
  * 连接分析：PageRank

### 2.3 数据挖掘需要具备的数学基础

* 概率论
* 线性代数
* 图论
* 最优化方法

## 3. Python引用

**引用模块/包**：**import**

```python

# 导入一个模块
import model_name
# 导入多个模块
import module_name1,module_name2
# 导入包中指定模块 
from package_name import moudule_name
# 导入包中所有模块 
from package_name import *
```

## 4. NumPy库

### 4.1 为什么要用NumPy而不用list?

答：在Python中list的元素在内存中的存储是分散的，而NumPy数据是存储在一个均匀连续的内存块中。这样数组计算遍历所有的元素，不像列表list还需要对内存地址进行查找，从而节省计算资源。并且在调用数据时，CPU可以利用矢量化功能调用内存中的整块NumPy数据，且NumPy的数据支持CPU的多线程处理。

### 4.2 NumPy里两个重要的对象

1. **ndarray(N-dimensional array object)**：

   * 作用：解决多维数组问题

   * 前言：在NumPy数组中，维数称为秩(rank)，一维数组的秩为1，二维数组的秩为2，以此类推。在NumPy中，每一个线性的数组称为一个轴(axes)，其实秩就是描述轴的数量。

   * 使用：

     * 创建数组：

       ```python
       import numpy as np
       a = np.array([1, 2, 3])
       b = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
       print(b)
       b[1, 1] = 10
       print(b)
       print(a.shape)
       print(b.shape)
       print(a.dtype) # 查看a矩阵中数据的类型
       ```

       运行结果：

       ```python
       [[1 2 3]
        [4 5 6]
        [7 8 9]]
       [[ 1  2  3]
        [ 4 10  6]
        [ 7  8  9]]
       (3,)
       (3, 3)
       int32
       ```

     * 结构数组：

       * 跟c语言中的结构体类似

       ```python
       import numpy as np
       persontype = np.dtype({
           'names' : ['name', 'age', 'chinese', 'math', 'english'],
           'formats' : ['S32', 'i', 'i', 'i', 'f']})
       peoples = np.array([("ZhangFei", 32, 75, 100, 90), ("GuanYu", 24, 85, 96, 88.5), ("ZhaoYun", 28, 85, 92, 96.5), ("HuangZhong", 29, 65, 85, 100)], dtype = persontype)
       ages = peoples[:]['age']
       chineses = peoples[:]['chinese']
       maths = peoples[:]['math']
       englishs = peoples[:]['english']
       print(np.mean(ages)) # mean是求平均值
       print(np.mean(chineses))
       print(np.mean(maths))
       print(np.mean(englishs))
       ```

       运行结果：

       ```python
       28.25
       77.5
       93.25
       93.75
       ```

       

2. **ufunc(universal function object)**：

   * 作用：解决对数组进行处理的函数

   * 使用：

     * 连续数组的创建：

       ```python
       x1 = np.arange(1, 11, 2)
       x2 = np.linspace(1, 9, 5)
       print(x1)
       print(x2)
       ```

       运行结果：

       ```python
       [1 3 5 7 9]
       [1. 3. 5. 7. 9.]
       ```

       总结：忽略数据类型的话，结果都是1，3，5，7，9，但两者的创建方式是不同的。

       * arange()类似内置函数range()，通过指定**初始值、终值、步长**来创建等差数列的一维数组，默认是不包括终值。
       * linspace是linear space的缩写，代表线性等分向量的含义。linspace()通过指定**初始值、终值、元素**个数来创建等差数列的一维数组，默认是包括终值的。

     * 算数运算：

       * 进行加、减、乘、除、求n次方和取余数

       ```python
       x1 = np.arange(1, 11, 2)
       x2 = np.linspace(1, 9, 5)
       print(np.add(x1, x2)) # 加
       print(np.subtract(x1, x2)) # 减
       print(np.multiply(x1, x2)) # 乘
       print(np.divide(x1, x2)) # 除
       print(np.power(x1, x2)) # 求n次方
       print(np.remainder(x1, x2)) # 取余数，np.mod(x1, x2)也是
       ```

       运行结果：

       ```python
       [ 2.  6. 10. 14. 18.]
       [0. 0. 0. 0. 0.]
       [ 1.  9. 25. 49. 81.]
       [1. 1. 1. 1. 1.]
       [1.00000000e+00 2.70000000e+01 3.12500000e+03 8.23543000e+05
        3.87420489e+08]
       [0. 0. 0. 0. 0.]
       ```

     * 统计函数

       * 计算数组/矩阵中的最大值函数amax()，最小值函数amin()

       ```python
       import numpy as np
       a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
       print(np.amin(a))
       print(np.amin(a, 0)) # 0代表找每一列最小值
       print(np.amin(a, 1)) # 1代表找每一行最小值
       print(np.amax(a))
       print(np.amax(a, 0)) # 找每一列最大值
       print(np.amax(a, 1)) # 找每一行最大值
       ```

       运行结果：

       ```python
       1
       [1 2 3]
       [1 4 7]
       9
       [7 8 9]
       [3 6 9]
       ```

       * 统计最大值与最小值之差ptp()

       ```python
       a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
       print(np.ptp(a))
       print(np.ptp(a, 0)) # 找每一列最大值跟最小值之差
       print(np.ptp(a, 1)) # 找每一行最大值跟最小值之差
       ```

       运行结果：

       ```python
       8
       [6 6 6]
       [2 2 2]
       ```

       * 统计数组的百分位数percentile()

       ```python
       # 统计数组的百分位数
       a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
       print(np.percentile(a, 50)) # 第二个参数代表p，p的取值范围是0-100，如果p=0.那么是求最小值，p=50就是求平均值，p=100就是求最大值
       print(np.percentile(a, 50, axis = 0))
       ```

       运行结果：

       ```python
       5.0
       [4. 5. 6.]
       [2. 5. 8.]
       ```

       * 统计数组中的中位数median()、平均数mean()

       ```python
       a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
       # 求中位数
       print(np.median(a))
       print(np.median(a, axis = 0))
       print(np.median(a, axis = 1))
       # 求平均数
       print(np.mean(a))
       print(np.mean(a, axis = 0))
       print(np.mean(a, axis = 1))
       ```

       运行结果：

       ```python
       5.0
       [4. 5. 6.]
       [2. 5. 8.]
       5.0
       [4. 5. 6.]
       [2. 5. 8.]
       ```

       * 统计数组中的加权平均值average()

       ```python
       # 统计数组中的加权平均值
       a = np.array([1, 2, 3, 4])
       wts = np.array([1, 2, 3, 4])
       print(np.average(a)) # （1 + 2 + 3 + 4)/4 = 2.5,默认情况下权重每个元素都是1
       print(np.average(a, weights = wts)) # (1 * 1 + 2 * 2 + 3 * 3 + 4 * 4)/(1 + 2 + 3 + 4) = 3.0
       ```

       * 统计数组中的标准差std()、方差var()

         方差的计算是指每个数值与平均值之差的平方求和的平均值

         即`mean((x - x.mean())**2)`

       ```python
       a = np.array([1, 2, 3, 4])
       print(np.std(a)) # 求这组数据的标准差
       print(np.var(a)) # 求这组数据的方差
       ```

       运行结果：

       ```python
       1.118033988749895
       1.25
       ```

     * 排序

       * sort函数：`sort(对象, axis=-1, kind='quicksort', order=None)`

         * axis默认是-1，即沿着数组的最后一个轴进行排序。当然它的值可以指定为None，即把所有元素采用扁平化的方式作为一个向量进行排序
         * order是用于结构化数组排序中，可以按照某个字段进行排序
         * kind默认是quicksort，可以指定mergesort、heapsort等

       * 使用：

         ```python
         # 排序
         a = np.array([[4,3,2],[2,4,1]])
         print(np.sort(a)) # 即按axis = -1也就是=1来排
         print(np.sort(a, axis=None)) # 当作一个向量来排
         print(np.sort(a, axis=0))  
         print(np.sort(a, axis=1))  
         ```

         运行结果：

         ```python
         [[2 3 4]
          [1 2 4]]
         [1 2 2 3 4 4]
         [[2 3 1]
          [4 4 2]]
         [[2 3 4]
          [1 2 4]]
         ```

         

     